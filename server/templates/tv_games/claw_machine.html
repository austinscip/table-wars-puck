<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üé∞ CLAW MACHINE - Table Wars</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            font-family: 'Arial Black', Arial, sans-serif;
            overflow: hidden;
        }
        #gameCanvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 32px;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.8);
            z-index: 100;
        }
        .score {
            font-size: 48px;
            color: #FFD700;
            margin: 10px 0;
        }
        .attempts {
            font-size: 36px;
            color: #FF6B6B;
        }
        #instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 20px 40px;
            border-radius: 15px;
            color: white;
            text-align: center;
            font-size: 24px;
        }
        .game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            padding: 50px;
            border-radius: 20px;
            text-align: center;
            display: none;
        }
        .game-over h1 {
            color: #FFD700;
            font-size: 64px;
            margin-bottom: 20px;
        }
        .game-over p {
            color: white;
            font-size: 36px;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>

    <div id="hud">
        <div>üé∞ CLAW MACHINE</div>
        <div class="score">SCORE: <span id="scoreValue">0</span></div>
        <div class="attempts">ATTEMPTS: <span id="attemptsValue">5</span></div>
    </div>

    <div id="instructions">
        <strong>TILT PUCK</strong> to move claw | <strong>HOLD BUTTON</strong> to grab prize!
    </div>

    <div class="game-over" id="gameOver">
        <h1>üéÅ GAME OVER!</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
    </div>

    <script>
        const puckId = {{ puck_id }};
        const socket = io();

        // Three.js setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB);
        scene.fog = new THREE.Fog(0x87CEEB, 10, 50);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 12);
        camera.lookAt(0, 2, 0);

        const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('gameCanvas'), antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);

        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.mapSize.width = 2048;
        directionalLight.shadow.mapSize.height = 2048;
        scene.add(directionalLight);

        // Claw machine cabinet
        const cabinetGeometry = new THREE.BoxGeometry(8, 10, 6);
        const cabinetMaterial = new THREE.MeshPhongMaterial({
            color: 0xFF1493,
            transparent: true,
            opacity: 0.3,
            side: THREE.DoubleSide
        });
        const cabinet = new THREE.Mesh(cabinetGeometry, cabinetMaterial);
        cabinet.position.y = 5;
        scene.add(cabinet);

        // Floor of machine
        const floorGeometry = new THREE.PlaneGeometry(7.5, 5.5);
        const floorMaterial = new THREE.MeshPhongMaterial({ color: 0x4169E1 });
        const floor = new THREE.Mesh(floorGeometry, floorMaterial);
        floor.rotation.x = -Math.PI / 2;
        floor.position.y = 0.1;
        floor.receiveShadow = true;
        scene.add(floor);

        // Claw group
        const clawGroup = new THREE.Group();

        // Claw cable
        const cableGeometry = new THREE.CylinderGeometry(0.05, 0.05, 8, 8);
        const cableMaterial = new THREE.MeshPhongMaterial({ color: 0x333333 });
        const cable = new THREE.Mesh(cableGeometry, cableMaterial);
        cable.position.y = 4;
        clawGroup.add(cable);

        // Claw head
        const clawHeadGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const clawHeadMaterial = new THREE.MeshPhongMaterial({ color: 0xFFD700 });
        const clawHead = new THREE.Mesh(clawHeadGeometry, clawHeadMaterial);
        clawHead.castShadow = true;
        clawGroup.add(clawHead);

        // Claw fingers (4 fingers)
        const clawFingers = [];
        for (let i = 0; i < 4; i++) {
            const fingerGeometry = new THREE.BoxGeometry(0.1, 0.6, 0.1);
            const fingerMaterial = new THREE.MeshPhongMaterial({ color: 0xC0C0C0 });
            const finger = new THREE.Mesh(fingerGeometry, fingerMaterial);
            finger.position.y = -0.3;

            const angle = (i / 4) * Math.PI * 2;
            finger.position.x = Math.cos(angle) * 0.25;
            finger.position.z = Math.sin(angle) * 0.25;
            finger.rotation.z = Math.cos(angle) * 0.3;
            finger.rotation.x = Math.sin(angle) * 0.3;
            finger.castShadow = true;

            clawHead.add(finger);
            clawFingers.push(finger);
        }

        scene.add(clawGroup);

        // Prizes
        const prizes = [];
        const prizeColors = {
            'teddy': 0x8B4513,
            'console': 0x000000,
            'cash': 0x00FF00,
            'gold_ring': 0xFFD700
        };

        function createPrize(data) {
            let geometry;
            if (data.type === 'teddy') {
                geometry = new THREE.SphereGeometry(0.4, 16, 16);
            } else if (data.type === 'console') {
                geometry = new THREE.BoxGeometry(0.6, 0.4, 0.6);
            } else if (data.type === 'cash') {
                geometry = new THREE.BoxGeometry(0.5, 0.1, 0.3);
            } else {
                geometry = new THREE.TorusGeometry(0.25, 0.1, 16, 32);
            }

            const material = new THREE.MeshPhongMaterial({
                color: prizeColors[data.type],
                emissive: prizeColors[data.type],
                emissiveIntensity: 0.2
            });
            const mesh = new THREE.Mesh(geometry, material);

            // Convert game coordinates (0-100) to world coordinates
            mesh.position.x = (data.x - 50) / 50 * 3.5;
            mesh.position.z = (data.y - 50) / 50 * 2.5;
            mesh.position.y = (100 - data.z) / 100 * 8 + 0.3;

            mesh.castShadow = true;
            mesh.userData = data;

            scene.add(mesh);
            prizes.push(mesh);

            return mesh;
        }

        // Game state
        let gameState = null;

        // Socket events
        socket.on('connect', () => {
            console.log('Connected to server');
            socket.emit('join_game_room', { puck_id: puckId });
            socket.emit('request_game_state', { puck_id: puckId });
        });

        socket.on('game_state_update', (state) => {
            gameState = state;
            updateGame(state);
        });

        socket.on('game_over', (data) => {
            document.getElementById('gameOver').style.display = 'block';
            document.getElementById('finalScore').textContent = data.state.score;
        });

        function updateGame(state) {
            // Update HUD
            document.getElementById('scoreValue').textContent = state.score;
            document.getElementById('attemptsValue').textContent = state.attempts_remaining;

            // Update claw position
            const clawX = (state.claw_x - 50) / 50 * 3.5;
            const clawZ = (state.claw_y - 50) / 50 * 2.5;
            const clawY = 8 - (state.claw_z / 100 * 7);

            clawGroup.position.x = clawX;
            clawGroup.position.z = clawZ;
            clawGroup.position.y = clawY;

            // Update claw open/close
            const fingerAngle = state.claw_open ? 0.3 : 0.8;
            clawFingers.forEach((finger, i) => {
                const angle = (i / 4) * Math.PI * 2;
                finger.rotation.z = Math.cos(angle) * fingerAngle;
                finger.rotation.x = Math.sin(angle) * fingerAngle;
            });

            // Update prizes
            prizes.forEach(prize => scene.remove(prize));
            prizes.length = 0;

            state.prizes.forEach(prizeData => {
                if (!prizeData.grabbed) {
                    createPrize(prizeData);
                }
            });

            // If prize is grabbed, attach to claw
            if (state.grabbed_prize) {
                const grabbedGeometry = new THREE.SphereGeometry(0.3, 16, 16);
                const grabbedMaterial = new THREE.MeshPhongMaterial({
                    color: prizeColors[state.grabbed_prize.type],
                    emissive: 0xFFFF00,
                    emissiveIntensity: 0.5
                });
                const grabbedMesh = new THREE.Mesh(grabbedGeometry, grabbedMaterial);
                grabbedMesh.position.y = -0.8;
                clawHead.add(grabbedMesh);
            } else {
                // Remove any attached prizes
                while(clawHead.children.length > 4) {
                    clawHead.remove(clawHead.children[clawHead.children.length - 1]);
                }
            }
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Gentle camera sway
            camera.position.x = Math.sin(Date.now() * 0.0003) * 0.5;
            camera.lookAt(0, 2, 0);

            // Rotate prizes slowly
            prizes.forEach(prize => {
                prize.rotation.y += 0.01;
            });

            renderer.render(scene, camera);
        }

        animate();

        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
