<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Balance Hold - Table Wars</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      overflow: hidden;
      color: white;
    }

    #game-container {
      text-align: center;
      width: 100%;
      max-width: 1200px;
      padding: 40px;
    }

    h1 {
      font-size: 4rem;
      font-weight: 900;
      margin-bottom: 20px;
      text-shadow: 0 4px 20px rgba(0,0,0,0.3);
      letter-spacing: -2px;
    }

    #instructions {
      font-size: 1.5rem;
      margin-bottom: 40px;
      opacity: 0.9;
    }

    #game-canvas {
      display: block;
      margin: 40px auto;
      background: rgba(255, 255, 255, 0.1);
      border-radius: 20px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.4);
    }

    #timer {
      font-size: 3rem;
      font-weight: 700;
      margin-bottom: 20px;
    }

    #score {
      font-size: 2rem;
      font-weight: 700;
      margin-bottom: 20px;
      color: #4ECDC4;
    }

    #streak {
      font-size: 1.5rem;
      margin-bottom: 20px;
      color: #FFD93D;
    }

    #difficulty-meter {
      font-size: 1.3rem;
      margin-bottom: 30px;
      opacity: 0.8;
    }

    #start-btn {
      background: white;
      color: #667eea;
      border: none;
      padding: 30px 60px;
      font-size: 2rem;
      font-weight: 900;
      border-radius: 100px;
      cursor: pointer;
      box-shadow: 0 10px 40px rgba(0,0,0,0.3);
      transition: all 0.3s ease;
      text-transform: uppercase;
      letter-spacing: 2px;
    }

    #start-btn:hover {
      transform: translateY(-5px);
      box-shadow: 0 15px 50px rgba(0,0,0,0.4);
    }

    .hidden {
      display: none;
    }

    #results {
      display: none;
      animation: slideIn 0.5s ease;
    }

    @keyframes slideIn {
      from {
        opacity: 0;
        transform: translateY(30px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    #final-score {
      font-size: 8rem;
      font-weight: 900;
      color: #ffd93d;
      text-shadow: 0 8px 40px rgba(255, 217, 61, 0.5);
      margin: 40px 0;
    }

    #rating {
      font-size: 2.5rem;
      margin-bottom: 40px;
    }

    #keyboard-hint {
      position: fixed;
      bottom: 30px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 1.2rem;
      opacity: 0.5;
      background: rgba(0,0,0,0.3);
      padding: 15px 30px;
      border-radius: 50px;
    }

    .danger-zone {
      animation: pulse 0.5s ease infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.8; }
      50% { opacity: 1; }
    }
  </style>
</head>
<body>
  <div id="game-container">
    <div id="lobby">
      <h1>‚öñÔ∏è BALANCE HOLD ‚öñÔ∏è</h1>
      <p id="instructions">Keep the ball in the center zone for 30 seconds!</p>
      <button id="start-btn" onclick="startGame()">START GAME</button>
    </div>

    <div id="gameplay" class="hidden">
      <h1>‚öñÔ∏è BALANCE HOLD ‚öñÔ∏è</h1>
      <div id="timer">30.0s</div>
      <canvas id="game-canvas" width="600" height="600"></canvas>
      <div id="score">Score: 0</div>
      <div id="streak">Perfect Balance Streak: 0</div>
      <div id="difficulty-meter">Difficulty: Easy</div>
    </div>

    <div id="results">
      <h1>üéâ GAME COMPLETE! üéâ</h1>
      <div id="final-score">0</div>
      <div id="rating">Loading...</div>
      <button id="start-btn" onclick="resetGame()">PLAY AGAIN</button>
    </div>
  </div>

  <div id="keyboard-hint">Arrow Keys to tilt (simulates puck tilt)</div>

  <script>
    // Game State
    let gameState = 'LOBBY'; // LOBBY, PLAYING, RESULTS
    let score = 0;
    let timeRemaining = 30.0;
    let streak = 0;
    let difficulty = 1;

    // Ball Physics
    let ballX = 300;
    let ballY = 300;
    let ballVelX = 0;
    let ballVelY = 0;
    let ballRadius = 20;

    // Platform Tilt (simulates accelerometer)
    let tiltX = 0; // -1 to 1
    let tiltY = 0; // -1 to 1

    // Zone sizes
    const perfectZone = 50;
    const goodZone = 100;
    const dangerZone = 250;

    // Canvas
    const canvas = document.getElementById('game-canvas');
    const ctx = canvas.getContext('2d');

    // Audio
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // DOM Elements
    const lobby = document.getElementById('lobby');
    const gameplay = document.getElementById('gameplay');
    const results = document.getElementById('results');
    const timerDisplay = document.getElementById('timer');
    const scoreDisplay = document.getElementById('score');
    const streakDisplay = document.getElementById('streak');
    const difficultyDisplay = document.getElementById('difficulty-meter');
    const finalScore = document.getElementById('final-score');
    const rating = document.getElementById('rating');

    // Keyboard Input (simulates puck tilt)
    const keys = {};

    document.addEventListener('keydown', (e) => {
      keys[e.key] = true;
    });

    document.addEventListener('keyup', (e) => {
      keys[e.key] = false;
    });

    function startGame() {
      gameState = 'PLAYING';
      lobby.classList.add('hidden');
      gameplay.classList.remove('hidden');
      results.style.display = 'none';

      // Reset state
      score = 0;
      timeRemaining = 30.0;
      streak = 0;
      difficulty = 1;
      ballX = 300;
      ballY = 300;
      ballVelX = 0;
      ballVelY = 0;

      updateDisplay();

      // Start game loop
      requestAnimationFrame(gameLoop);
    }

    function gameLoop() {
      if (gameState === 'PLAYING') {
        update();
        render();
        requestAnimationFrame(gameLoop);
      }
    }

    function update() {
      // Update timer
      timeRemaining -= 1/60;
      if (timeRemaining <= 0) {
        endGame();
        return;
      }

      // Get tilt from keyboard
      tiltX = 0;
      tiltY = 0;
      if (keys['ArrowLeft']) tiltX = -1;
      if (keys['ArrowRight']) tiltX = 1;
      if (keys['ArrowUp']) tiltY = -1;
      if (keys['ArrowDown']) tiltY = 1;

      // Apply tilt to ball velocity (gravity simulation)
      const gravity = 0.5 * difficulty;
      ballVelX += tiltX * gravity;
      ballVelY += tiltY * gravity;

      // Friction
      ballVelX *= 0.98;
      ballVelY *= 0.98;

      // Update ball position
      ballX += ballVelX;
      ballY += ballVelY;

      // Bounce off walls
      if (ballX - ballRadius < 0) {
        ballX = ballRadius;
        ballVelX = Math.abs(ballVelX) * 0.7;
        playBounce();
      }
      if (ballX + ballRadius > canvas.width) {
        ballX = canvas.width - ballRadius;
        ballVelX = -Math.abs(ballVelX) * 0.7;
        playBounce();
      }
      if (ballY - ballRadius < 0) {
        ballY = ballRadius;
        ballVelY = Math.abs(ballVelY) * 0.7;
        playBounce();
      }
      if (ballY + ballRadius > canvas.height) {
        ballY = canvas.height - ballRadius;
        ballVelY = -Math.abs(ballVelY) * 0.7;
        playBounce();
      }

      // Calculate distance from center
      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;
      const distanceFromCenter = Math.sqrt(
        Math.pow(ballX - centerX, 2) + Math.pow(ballY - centerY, 2)
      );

      // Scoring based on zone
      if (distanceFromCenter < perfectZone) {
        // Perfect zone - high points
        score += 10;
        streak++;
        if (streak % 60 === 0) { // Every second
          playPerfectSound();
        }
      } else if (distanceFromCenter < goodZone) {
        // Good zone - medium points
        score += 5;
        if (streak > 0) streak--;
      } else if (distanceFromCenter < dangerZone) {
        // Okay zone - small points
        score += 1;
        streak = 0;
      } else {
        // Danger zone - no points
        streak = 0;
        if (Math.floor(timeRemaining * 10) % 5 === 0) {
          playWarning();
        }
      }

      // Increase difficulty over time
      if (timeRemaining < 20) difficulty = 1.2;
      if (timeRemaining < 10) difficulty = 1.5;

      updateDisplay();
    }

    function render() {
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const centerX = canvas.width / 2;
      const centerY = canvas.height / 2;

      // Draw zones
      // Danger zone
      ctx.beginPath();
      ctx.arc(centerX, centerY, dangerZone, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(255, 71, 87, 0.2)';
      ctx.fill();

      // Good zone
      ctx.beginPath();
      ctx.arc(centerX, centerY, goodZone, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(255, 217, 61, 0.3)';
      ctx.fill();

      // Perfect zone
      ctx.beginPath();
      ctx.arc(centerX, centerY, perfectZone, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(78, 205, 196, 0.5)';
      ctx.fill();

      // Draw center target
      ctx.beginPath();
      ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
      ctx.fillStyle = 'white';
      ctx.fill();

      // Draw crosshair
      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(centerX - 20, centerY);
      ctx.lineTo(centerX + 20, centerY);
      ctx.moveTo(centerX, centerY - 20);
      ctx.lineTo(centerX, centerY + 20);
      ctx.stroke();

      // Draw ball
      const distanceFromCenter = Math.sqrt(
        Math.pow(ballX - centerX, 2) + Math.pow(ballY - centerY, 2)
      );

      let ballColor = '#4ECDC4'; // Perfect
      if (distanceFromCenter > perfectZone) ballColor = '#FFD93D'; // Good
      if (distanceFromCenter > goodZone) ballColor = '#FFA500'; // Okay
      if (distanceFromCenter > dangerZone) ballColor = '#FF4757'; // Danger

      // Ball shadow
      ctx.beginPath();
      ctx.arc(ballX + 5, ballY + 5, ballRadius, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
      ctx.fill();

      // Ball
      ctx.beginPath();
      ctx.arc(ballX, ballY, ballRadius, 0, 2 * Math.PI);
      ctx.fillStyle = ballColor;
      ctx.fill();
      ctx.strokeStyle = 'white';
      ctx.lineWidth = 3;
      ctx.stroke();

      // Ball highlight
      ctx.beginPath();
      ctx.arc(ballX - 7, ballY - 7, 6, 0, 2 * Math.PI);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
      ctx.fill();

      // Draw tilt indicator (optional debug)
      if (tiltX !== 0 || tiltY !== 0) {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(ballX, ballY);
        ctx.lineTo(ballX + tiltX * 40, ballY + tiltY * 40);
        ctx.stroke();
      }
    }

    function updateDisplay() {
      timerDisplay.textContent = timeRemaining.toFixed(1) + 's';
      scoreDisplay.textContent = 'Score: ' + score.toLocaleString();
      streakDisplay.textContent = 'Perfect Balance Streak: ' + Math.floor(streak / 60) + 's';

      if (difficulty === 1) {
        difficultyDisplay.textContent = 'Difficulty: Easy';
      } else if (difficulty === 1.2) {
        difficultyDisplay.textContent = 'Difficulty: Medium üî•';
      } else {
        difficultyDisplay.textContent = 'Difficulty: HARD üî•üî•';
      }

      // Change timer color when time running out
      if (timeRemaining < 5) {
        timerDisplay.style.color = '#FF4757';
        timerDisplay.classList.add('danger-zone');
      } else {
        timerDisplay.style.color = 'white';
        timerDisplay.classList.remove('danger-zone');
      }
    }

    function endGame() {
      gameState = 'RESULTS';
      gameplay.classList.add('hidden');
      results.style.display = 'block';

      // Animate final score
      let currentScore = 0;
      const scoreInterval = setInterval(() => {
        currentScore += Math.ceil(score / 20);
        if (currentScore >= score) {
          currentScore = score;
          clearInterval(scoreInterval);
        }
        finalScore.textContent = currentScore.toLocaleString();
      }, 50);

      // Rating
      let ratingText = '';
      if (score >= 10000) {
        ratingText = 'üèÜ PERFECT BALANCE MASTER! üèÜ';
      } else if (score >= 7000) {
        ratingText = '‚≠ê INCREDIBLE CONTROL! ‚≠ê';
      } else if (score >= 5000) {
        ratingText = 'üî• GREAT JOB! üî•';
      } else if (score >= 3000) {
        ratingText = 'üëç NICE WORK! üëç';
      } else if (score >= 1000) {
        ratingText = 'üòä GOOD TRY! üòä';
      } else {
        ratingText = 'üí™ KEEP PRACTICING! üí™';
      }

      rating.textContent = ratingText;

      playSuccessSound();
    }

    function resetGame() {
      gameState = 'LOBBY';
      results.style.display = 'none';
      lobby.classList.remove('hidden');
    }

    // Sound Effects
    function playBounce() {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      oscillator.frequency.value = 200;
      oscillator.type = 'sine';

      gainNode.gain.value = 0.1;
      gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.1);
    }

    function playPerfectSound() {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      oscillator.frequency.value = 600;
      oscillator.type = 'sine';

      gainNode.gain.value = 0.05;

      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.1);
    }

    function playWarning() {
      const oscillator = audioCtx.createOscillator();
      const gainNode = audioCtx.createGain();

      oscillator.connect(gainNode);
      gainNode.connect(audioCtx.destination);

      oscillator.frequency.value = 300;
      oscillator.type = 'square';

      gainNode.gain.value = 0.05;

      oscillator.start();
      oscillator.stop(audioCtx.currentTime + 0.1);
    }

    function playSuccessSound() {
      const notes = [261.63, 329.63, 392.00, 523.25];
      notes.forEach((freq, i) => {
        setTimeout(() => {
          const oscillator = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();

          oscillator.connect(gainNode);
          gainNode.connect(audioCtx.destination);

          oscillator.frequency.value = freq;
          oscillator.type = 'sine';
          gainNode.gain.value = 0.2;

          oscillator.start();
          oscillator.stop(audioCtx.currentTime + 0.3);
        }, i * 200);
      });
    }
  </script>
</body>
</html>
